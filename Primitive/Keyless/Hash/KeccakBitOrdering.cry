/**
 * Functions for converting bit string representations used in Keccak.
 *
 * This has methods for converting between the standard bit ordering in Cryptol
 * (big endian, or most significant bit first (MSB)) and the bit ordering
 * used in Keccak (bytes in MSB order, but the bits in each byte are in
 * least significant bit first (LSB) order).
 *
 * @copyright Galois, Inc.
 * @author Ajay Kumar Eeralla
 * @author Marcella Hastings <marcella@galois.com>
 */
module Primitive::Keyless::Hash::KeccakBitOrdering where
/** Splits a list of bits into bytes, using little-endian bit order. **/
toBytes : {n} (fin n) => [8*n] -> [n][8]
toBytes s = reverse (split (reverse s))

/** Joins a list of bytes into a list of bits, using little-endian bit order. **/
fromBytes : {n} (fin n) => [n][8] -> [8*n]
fromBytes bs = reverse (join (reverse bs))

/**
 * This converts between a bit vector in MSB order and a bit vector in SHA-3
 * bit ordering (the bytes are in MSB order; the bits in each byte are in LSB
 * order).
 *
 * For arbitrary-length strings, the conversion is symmetric. This can be used
 * to convert from SHA-3 strings into MSB strings, or from MSB strings into
 * SHA-3 strings.
 *
 * This function does not have an explicit equivalent in the [FIPS-202]. It
 * differs from the conversion functions in Appendix B.1 in several ways:
 * - The h2b and b2h functions expect the non-SHA-3 bit vector to be a
 *   hexadecimal string with an even number of digits. This function
 *   can handle a non-SHA-3 bit vector of any length (including infinite
 *   length).
 * - The h2b and b2h functions take a separate parameter `n` specifying the
 *   "actual" length of the non-SHA-3 bit vector. `h2b` truncates the SHA-3 bit
 *   vector to exactly `n` bits; `b2h` pads the non-SHA-3 bit vector to a
 *   multiple of 8 bits. This function assumes the input bit vector
 *   has no padding and that the output bit vector is exactly the same length
 *   as the input bit vector.
 *
 * [FIPS-202] does not specify when these conversion functions are expected to
 * be used. The CAVP test vectors provided by NIST use the format consumed by
 * `h2b` and `b2h` of hexadecimal strings with an even number of digits.
 * However, we anticipate that many applications will produce exact-length
 * messages to use with SHA-3 functions (e.g. they will not pad their inputs
 * to a multiple of 8 bits).
 *
 * Sources:
 * A blog post with some references to other versions of the spec, explaining
 * the overall bit ordering scheme:
 * @see https://cryptologie.net/article/387/byte-ordering-and-bit-numbering-in-keccak-and-sha-3/
 * The CAVP test vectors from NIST:
 * @see https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/example-values#Hashing
 */
reverseBitOrdering : {m} [m] -> [m]
reverseBitOrdering msg
    | m == inf => join (map reverse (groupBy`{8} msg))
    | fin m => (flipped_full_bytes # flipped_remainder) where
        // This is number of bits in the set of "complete" bytes in the input
        // There are `m % 8` bits remaining.
        type Bytes = 8 * (m / 8)
        flipped_full_bytes = join (map reverse (groupBy`{each=8, parts=m /8} (take`{Bytes} msg)))
        flipped_remainder = reverse (drop`{Bytes} msg)

/**
 * The conversion between SHA-3 strings and MSB strings is its own inverse.
 * ```repl
 * :prove reverseBitOrderingInvolutes`{100}
 * ```
 */
reverseBitOrderingInvolutes : {m} (fin m) => [m] -> Bit
property reverseBitOrderingInvolutes msg = reReverse == msg where
    reReverse = reverseBitOrdering (reverseBitOrdering msg)

/**
 * A hex digit is represented in Cryptol as a 4-bit vector.
 */
type HexDigit = 4

/**
 * Converts a hexadecimal string with an even number of digits into a SHA-3
 * string.
 *
 * The bit ordering expected by Keccak has bytes in MSB order, and the bits in
 * each byte in LSB order. (Cryptol's default interprets both bits and bytes
 * in MSB order).
 *
 * [FIPS-202] Appendix B.1, Algorithm 10.
 */
h2b: {n, m} (fin m, m >= 1, n <= 8 * m) => [2 * m * HexDigit] -> [n]
h2b msg = S where
    // Step 1.
    H = groupBy`{HexDigit} msg
    // Type conversion: expand each 4-bit digit into an 8-bit vector to support
    // subsequent operations.
    H8 = map zext H : [2 * m][8]
    // Step 2a.
    hs = [16 * H8 @ (2 * i) + H8 @ (2 * i + 1) | i <- [0..m-1]]
    // Step 2b.
    // Cryptol defaults to MSB order; this step arranges the bits in LSB order.
    bs = map reverse hs
    // Step 3.
    T = join bs
    // Step 4.
    S = take`{n} T

/**
 * This is the example in [FIPS-202] Appendix B, Table 5.
 * ```repl
 * :prove h2bExampleWorks
 * ```
 */
property h2bExampleWorks = h2b`{14} H == S where
    H = 0xA32E
    S = 0b11000101011101